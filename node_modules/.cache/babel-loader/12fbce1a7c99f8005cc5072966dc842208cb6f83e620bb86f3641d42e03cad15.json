{"ast":null,"code":"\"use client\";\n\n// src/useQueries.ts\nimport _slicedToArray from \"/home/arthur/Documents/CmrRestaurant-management-system/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/home/arthur/Documents/CmrRestaurant-management-system/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"queries\"];\nimport * as React from \"react\";\nimport { QueriesObserver, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch } from \"./suspense.js\";\nfunction useQueries(_ref, queryClient) {\n  var queries = _ref.queries,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var client = useQueryClient(queryClient);\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedQueries = React.useMemo(function () {\n    return queries.map(function (opts) {\n      var defaultedOptions = client.defaultQueryOptions(opts);\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    });\n  }, [queries, client, isRestoring]);\n  defaultedQueries.forEach(function (query) {\n    ensureStaleTime(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  var _React$useState = React.useState(function () {\n      return new QueriesObserver(client, defaultedQueries, options);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    observer = _React$useState2[0];\n  var _observer$getOptimist = observer.getOptimisticResult(defaultedQueries),\n    _observer$getOptimist2 = _slicedToArray(_observer$getOptimist, 3),\n    optimisticResult = _observer$getOptimist2[0],\n    getCombinedResult = _observer$getOptimist2[1],\n    trackResult = _observer$getOptimist2[2];\n  React.useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return void 0;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    observer.setQueries(defaultedQueries, options, {\n      listeners: false\n    });\n  }, [defaultedQueries, options, observer]);\n  var shouldAtLeastOneSuspend = optimisticResult.some(function (result, index) {\n    return shouldSuspend(defaultedQueries[index], result, isRestoring);\n  });\n  var suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap(function (result, index) {\n    var opts = defaultedQueries[index];\n    var queryObserver = observer.getObservers()[index];\n    if (opts && queryObserver) {\n      if (shouldSuspend(opts, result, isRestoring)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  var observerQueries = observer.getQueries();\n  var firstSingleResultWhichShouldThrow = optimisticResult.find(function (result, index) {\n    var _defaultedQueries$ind, _defaultedQueries$ind2;\n    return getHasError({\n      result: result,\n      errorResetBoundary: errorResetBoundary,\n      throwOnError: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) === null || _defaultedQueries$ind2 === void 0 ? void 0 : _defaultedQueries$ind2.throwOnError) !== null && _defaultedQueries$ind !== void 0 ? _defaultedQueries$ind : false,\n      query: observerQueries[index]\n    });\n  });\n  if (firstSingleResultWhichShouldThrow !== null && firstSingleResultWhichShouldThrow !== void 0 && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport { useQueries };","map":{"version":3,"names":["React","QueriesObserver","notifyManager","useQueryClient","useIsRestoring","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureStaleTime","fetchOptimistic","shouldSuspend","willFetch","useQueries","_ref","queryClient","queries","options","_objectWithoutProperties","_excluded","client","isRestoring","errorResetBoundary","defaultedQueries","useMemo","map","opts","defaultedOptions","defaultQueryOptions","_optimisticResults","forEach","query","_React$useState","useState","_React$useState2","_slicedToArray","observer","_observer$getOptimist","getOptimisticResult","_observer$getOptimist2","optimisticResult","getCombinedResult","trackResult","useSyncExternalStore","useCallback","onStoreChange","subscribe","batchCalls","getCurrentResult","useEffect","setQueries","listeners","shouldAtLeastOneSuspend","some","result","index","suspensePromises","flatMap","queryObserver","getObservers","length","Promise","all","observerQueries","getQueries","firstSingleResultWhichShouldThrow","find","_defaultedQueries$ind","_defaultedQueries$ind2","throwOnError","error"],"sources":["/home/arthur/Documents/CmrRestaurant-management-system/node_modules/@tanstack/react-query/src/useQueries.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'suspense'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        TError,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryResult<TData, unknown extends TError ? DefaultError : TError>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, any>\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryResult<\n        TQueryFnData,\n        unknown extends TError ? DefaultError : TError\n      >\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : Array<unknown> extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends Array<\n      UseQueryOptionsForUseQueries<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        infer TQueryKey\n      >\n    >\n  ? Array<UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>>\n  : // Fallback\n    Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends Array<\n      UseQueryOptionsForUseQueries<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        any\n      >\n    >\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    Array<\n      UseQueryResult<\n        unknown extends TData ? TQueryFnData : TData,\n        unknown extends TError ? DefaultError : TError\n      >\n    >\n  : // Fallback\n    Array<UseQueryResult>\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(opts)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(defaultedQueries)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (opts && queryObserver) {\n          if (shouldSuspend(opts, result, isRestoring)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedQueries[index]?.throwOnError ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}